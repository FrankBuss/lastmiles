
At this point thanks to chat and Jefferson and guys like theddmage  :

vesta$ 
vesta$ valgrind --leak-check=full ./test_cplex > /dev/null
==96678== Memcheck, a memory error detector
==96678== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==96678== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==96678== Command: ./test_cplex
==96678== 
==96678== 
==96678== HEAP SUMMARY:
==96678==     in use at exit: 0 bytes in 0 blocks
==96678==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==96678== 
==96678== All heap blocks were freed -- no leaks are possible
==96678== 
==96678== For counts of detected and suppressed errors, rerun with: -v
==96678== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
vesta$ 

However we may need to look at that again in the future given all 
the changes we have done.

We fell into the basic complex math functions whereas complex.h can
cover all this for us in the double 64bit floating point space with : 

double               cabs(double complex);
double               carg(double complex);
double               cimag(double complex);
double               creal(double complex);
double complex       cacos(double complex);
double complex       cacosh(double complex);
double complex       casin(double complex);
double complex       casinh(double complex);
double complex       catan(double complex);
double complex       catanh(double complex);
double complex       ccos(double complex);
double complex       ccosh(double complex);
double complex       cexp(double complex);
double complex       clog(double complex);
double complex       conj(double complex);
double complex       cpow(double complex, double complex);
double complex       cproj(double complex);
double complex       csin(double complex);
double complex       csinh(double complex);
double complex       csqrt(double complex);
double complex       ctan(double complex);
double complex       ctanh(double complex);

We even have the same functions in the 32bit float : 

float                cabsf(float complex);
float                cargf(float complex);
float                cimagf(float complex);
float                crealf(float complex);
float complex        cacosf(float complex);
float complex        cacoshf(float complex);
float complex        casinf(float complex);
float complex        casinhf(float complex);
float complex        catanf(float complex);
float complex        catanhf(float complex);
float complex        ccosf(float complex);
float complex        ccoshf(float complex);
float complex        cexpf(float complex);
float complex        clogf(float complex);
float complex        conjf(float complex);
float complex        cpowf(float complex, float complex);
float complex        cprojf(float complex);
float complex        csinf(float complex);
float complex        csinhf(float complex);
float complex        csqrtf(float complex);
float complex        ctanf(float complex);
float complex        ctanhf(float complex);

There is no promise that we can rely up anything from the 128bit 
floating point world as various hardware implementations may or may
not exist and libquadmath is not cross platform and arm7 simply 
won't do anything past 64-bit and x86_64 is useless past 80-bits :

long double          cabsl(long double complex);
long double          cargl(long double complex);
long double          cimagl(long double complex);
long double          creall(long double complex);
long double complex  cacoshl(long double complex);
long double complex  cacosl(long double complex);
long double complex  casinhl(long double complex);
long double complex  casinl(long double complex);
long double complex  catanhl(long double complex);
long double complex  catanl(long double complex);
long double complex  ccoshl(long double complex);
long double complex  ccosl(long double complex);
long double complex  cexpl(long double complex);
long double complex  clogl(long double complex);
long double complex  conjl(long double complex);
long double complex  cpowl(long double complex, long double complex);
long double complex  cprojl(long double complex);
long double complex  csinhl(long double complex);
long double complex  csinl(long double complex);
long double complex  csqrtl(long double complex);
long double complex  ctanhl(long double complex);
long double complex  ctanl(long double complex);

Good luck with any of that.

Our own hard rolled complex math functions test with a questionable
quadratic result from the complex terms : 

dbug : op1 = ( 0, 1 )
     : op2 = ( 0, 1 )
     : opr = op1 * op2 = ( -1, 0 )
     :     should be i^2 = -1

dbug : op1 = ( 1, 0 )
     : op2 = ( 0, 1 )
     : opr = op1 * op2 = ( 0, 1 )
     :     should be 1i

dbug : op1 = ( -1, 0 )
     : op2 = ( 0, 0 )
     : opr = op1 * op2 = ( 0, 0 )
     :     should be just zero.

dbug : op1 = ( 4, 3 )
     : op2 = ( 2, -1 )
dbug : opr = op1 / op2 = ( 1, 2 )
     :     should be 1 + 2i

dbug : op1 = ( 4, 3 )
     : op2 = ( -4, -12 )
dbug : opr = op1 / op2 = ( -0.325, 0.225 )
     :     should be -0.325 + 0.225i

dbug : op1 = ( 2, 1 )
     :     theta = 4.636476090008e-01

dbug : op1 = ( 4, 3 )
     :     theta = 6.435011087933e-01
     : opr = op1^2 = ( 7, 24 )
     :     should be 7 + 24i
     :     magnitude is 25
     :     theta = 1.287002217587e+00
root : 1 is ( 5.000000000000e+00, 0.000000000000e+00 )
root : 2 is ( 5.000000000000e+00, 0.000000000000e+00 )

dbug : square root test
dbug : op1 = ( 0, 1 )
     :     theta = 1.570796326795e+00
     :     magnitude is 1
root : 1 is ( 1.000000000000e+00, 0.000000000000e+00 )
root : 2 is ( 1.000000000000e+00, 0.000000000000e+00 )

dbug : cube root test
     : op1 = ( -11, 2 )
     :     theta = 2.961739153797e+00
     :     magnitude is 11.1803
root : 1 is ( 1.232050807569e+00, 1.866025403784e+00 )
root : 2 is ( -2.232050807569e+00, 1.339745962156e-01 )
root : 3 is ( 1.000000000000e+00, -2.000000000000e+00 )

Lets test vector dot product
dbug : v1 = < ( 1, 1 ), ( 2, 2 ), ( 3, 3 ) >
     : v2 = < ( -1, -1 ), ( -2, -2 ), ( 3, -3 ) >
     : dot product = ( 18, -10 )

     : v1 cross v2 = < ( 12, 12 ), ( -6, -6 ), ( 0, 0 ) >


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( -9, 0 )
     : quad op3 = ( 14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 81, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( 56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( 25, 0 )
     : radicand roots1 is ( 5.000000000000e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 5.000000000000e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 9, 0 )

     : res[0] = ( 7.000000000000e+00, 0.000000000000e+00 )
     : res[1] = ( 7.000000000000e+00, 0.000000000000e+00 )
     : res[2] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[3] = ( 2.000000000000e+00, 0.000000000000e+00 )


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( 5, 0 )
     : quad op3 = ( -14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 25, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( -56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( 81, 0 )
     : radicand roots1 is ( 9.000000000000e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 9.000000000000e+00, 0.000000000000e+00 )

     : -1 * op2 = ( -5, 0 )

     : res[0] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[1] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[2] = ( -7.000000000000e+00, 0.000000000000e+00 )
     : res[3] = ( -7.000000000000e+00, 0.000000000000e+00 )


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( -5, 0 )
     : quad op3 = ( 14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 25, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( 56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( -31, 0 )
     : radicand roots1 is ( 5.567764362830e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 5.567764362830e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 5, 0 )

     : res[0] = ( 5.283882181415e+00, 0.000000000000e+00 )
     : res[1] = ( 5.283882181415e+00, 0.000000000000e+00 )
     : res[2] = ( -2.838821814150e-01, 0.000000000000e+00 )
     : res[3] = ( -2.838821814150e-01, 0.000000000000e+00 )


dbug : quad op1 = ( 2, 3 )
     : quad op2 = ( -5, 2 )
     : quad op3 = ( -1, -7 )
     : denom = 2 * op1 = ( 4, 6 )
     : tmp0 = op2^2 = ( 21, -20 )
     : tmp1 = four * op1 = ( 8, 12 )
     : tmp2 = four * op1 * op3 = ( 76, -68 )
     : radicand = op2^2 - four * op1 * op3 = ( -55, 48 )
     : radicand roots1 is ( 8.544003745318e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 8.544003745318e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 5, -2 )

     : res[0] = ( 8.110772111783e-01, -1.716615816767e+00 )
     : res[1] = ( 8.110772111783e-01, -1.716615816767e+00 )
     : res[2] = ( -5.033849034860e-01, 2.550773552289e-01 )
     : res[3] = ( -5.033849034860e-01, 2.550773552289e-01 )



The last result should be perhaps -23/13 - 11/13 i  and also 4/13 - 19/13 i


On SunOS 5.10 Generic_150400-65 SUNW,SPARC-Enterprise with c99 we see : 

dbug : op1 = ( 0, 1 )
     : op2 = ( 0, 1 )
     : opr = op1 * op2 = ( -1, 0 )
     :     should be i^2 = -1

dbug : op1 = ( 1, 0 )
     : op2 = ( 0, 1 )
     : opr = op1 * op2 = ( 0, 1 )
     :     should be 1i

dbug : op1 = ( -1, 0 )
     : op2 = ( 0, 0 )
     : opr = op1 * op2 = ( 0, 0 )
     :     should be just zero.

dbug : op1 = ( 4, 3 )
     : op2 = ( 2, -1 )
dbug : opr = op1 / op2 = ( 1, 2 )
     :     should be 1 + 2i

dbug : op1 = ( 4, 3 )
     : op2 = ( -4, -12 )
dbug : opr = op1 / op2 = ( -0.325, 0.225 )
     :     should be -0.325 + 0.225i

dbug : op1 = ( 2, 1 )
     :     theta = 4.636476090008e-01

dbug : op1 = ( 4, 3 )
     :     theta = 6.435011087933e-01
     : opr = op1^2 = ( 7, 24 )
     :     should be 7 + 24i
     :     magnitude is 25
     :     theta = 1.287002217587e+00
root : 1 is ( 5.000000000000e+00, 0.000000000000e+00 )
root : 2 is ( 5.000000000000e+00, 0.000000000000e+00 )

dbug : square root test
dbug : op1 = ( 0, 1 )
     :     theta = 1.570796326795e+00
     :     magnitude is 1
root : 1 is ( 1.000000000000e+00, 0.000000000000e+00 )
root : 2 is ( 1.000000000000e+00, 0.000000000000e+00 )

dbug : cube root test
     : op1 = ( -11, 2 )
     :     theta = 2.961739153797e+00
     :     magnitude is 11.1803
root : 1 is ( 1.232050807569e+00, 1.866025403784e+00 )
root : 2 is ( -2.232050807569e+00, 1.339745962156e-01 )
root : 3 is ( 1.000000000000e+00, -2.000000000000e+00 )

Lets test vector dot product
dbug : v1 = < ( 1, 1 ), ( 2, 2 ), ( 3, 3 ) >
     : v2 = < ( -1, -1 ), ( -2, -2 ), ( 3, -3 ) >
     : dot product = ( 18, -10 )

     : v1 cross v2 = < ( 12, 12 ), ( -6, -6 ), ( 0, 0 ) >


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( -9, 0 )
     : quad op3 = ( 14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 81, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( 56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( 25, 0 )
     : radicand roots1 is ( 5.000000000000e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 5.000000000000e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 9, 0 )

     : res[0] = ( 7.000000000000e+00, 0.000000000000e+00 )
     : res[1] = ( 7.000000000000e+00, 0.000000000000e+00 )
     : res[2] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[3] = ( 2.000000000000e+00, 0.000000000000e+00 )


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( 5, 0 )
     : quad op3 = ( -14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 25, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( -56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( 81, 0 )
     : radicand roots1 is ( 9.000000000000e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 9.000000000000e+00, 0.000000000000e+00 )

     : -1 * op2 = ( -5, 0 )

     : res[0] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[1] = ( 2.000000000000e+00, 0.000000000000e+00 )
     : res[2] = ( -7.000000000000e+00, 0.000000000000e+00 )
     : res[3] = ( -7.000000000000e+00, 0.000000000000e+00 )


dbug : quad op1 = ( 1, 0 )
     : quad op2 = ( -5, 0 )
     : quad op3 = ( 14, 0 )
     : denom = 2 * op1 = ( 2, 0 )
     : tmp0 = op2^2 = ( 25, 0 )
     : tmp1 = four * op1 = ( 4, 0 )
     : tmp2 = four * op1 * op3 = ( 56, 0 )
     : radicand = op2^2 - four * op1 * op3 = ( -31, 0 )
     : radicand roots1 is ( 5.567764362830e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 5.567764362830e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 5, 0 )

     : res[0] = ( 5.283882181415e+00, 0.000000000000e+00 )
     : res[1] = ( 5.283882181415e+00, 0.000000000000e+00 )
     : res[2] = ( -2.838821814150e-01, 0.000000000000e+00 )
     : res[3] = ( -2.838821814150e-01, 0.000000000000e+00 )


dbug : quad op1 = ( 2, 3 )
     : quad op2 = ( -5, 2 )
     : quad op3 = ( -1, -7 )
     : denom = 2 * op1 = ( 4, 6 )
     : tmp0 = op2^2 = ( 21, -20 )
     : tmp1 = four * op1 = ( 8, 12 )
     : tmp2 = four * op1 * op3 = ( 76, -68 )
     : radicand = op2^2 - four * op1 * op3 = ( -55, 48 )
     : radicand roots1 is ( 8.544003745318e+00, 0.000000000000e+00 )
     : radicand roots2 is ( 8.544003745318e+00, 0.000000000000e+00 )

     : -1 * op2 = ( 5, -2 )

     : res[0] = ( 8.110772111783e-01, -1.716615816767e+00 )
     : res[1] = ( 8.110772111783e-01, -1.716615816767e+00 )
     : res[2] = ( -5.033849034860e-01, 2.550773552289e-01 )
     : res[3] = ( -5.033849034860e-01, 2.550773552289e-01 )


Processed with : 

CC=/opt/developerstudio12.6/bin/c99

CFLAGS=-Xc -g -errfmt=error -erroff=%none -xmemalign=8s \
-errshort=full -xstrconst -xildoff -m64 -xnolibmil \
-xcode=pic32 -xregs=no%appl -xlibmieee -ftrap=%none \
-xarch=sparc -mc -xs -xbuiltin=%none -xdebugformat=dwarf \
-xunroll=1

CPPFLAGS= -D_POSIX_PTHREAD_SEMANTICS -D_LARGEFILE64_SOURCE -D_TS_ERRNO



Merely a late night and early morning note that we did check a single
test case with Cramer's Rule and we saw : 


Complex row data in row1 and row 3
dbug : row 1 = < ( 0.5, -1 ), ( -2, 0 ), ( -3, 0 ) >
     : row 2 = < ( 4, 0 ), ( 5, 0 ), ( 6, 0 ) >
     : row 3 = < ( 7, 0 ), ( -2, 4 ), ( 9, 0 ) >
     : det = ( 121.5, -117 )



Cramers rule test with existing matrix and
rh_col = < ( 1, 0.5 ), ( 2, 0.75 ), ( 3, -0.25 ) >
     : result col = < ( 5.857651245552e-01, 5.455516014235e-01 ),
                      ( -1.992882562278e-02, 1.937722419929e-01 ),
                      ( -4.056939501779e-02, -4.001779359431e-01 ) >

vesta$
vesta$
vesta$
vesta$ echo '16k 823 1405/p 1533 2810/p _28 1405 / p 1089 5620/p _57 1405/p _2249 5620/pq' | dc
.5857651245551601
.5455516014234875
-.0199288256227758
.1937722419928825
-.0405693950177935
-.4001779359430604
vesta$


see https://www.wolframalpha.com/input/?i=Solve+for+A%2CB%2CC+where+%28+0.5+-+i+%29+*+A++-+2+*+B+-+3+*+C+%3D+%28+1+%2B+0.5i+%29%2C+4+*+A+%2B+5+*+B+%2B+6+*+C+%3D+%28+2+%2B+0.75i+%29%2C++7+*+A+%2B+%28+-2+%2B+4i+%29+*+B+%2B+9+*+C+%3D+%28+3+-0.25i+%29.



